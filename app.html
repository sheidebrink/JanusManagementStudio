<!DOCTYPE html>
<html>
<head>
  <title>Janus Management Studio</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }
    .header {
      background: #667eea;
      color: white;
      padding: 15px;
      margin: -20px -20px 20px -20px;
    }
    .query-section {
      background: white;
      padding: 20px;
      border-radius: 5px;
      margin-bottom: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    textarea {
      width: 100%;
      height: 150px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-family: 'Courier New', monospace;
      resize: vertical;
    }
    button {
      background: #667eea;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 10px;
    }
    button:hover {
      background: #5a6fd8;
    }
    .results {
      background: white;
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-size: 12px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 6px;
      text-align: left;
      white-space: nowrap;
    }
    th {
      background: #f8f9fa;
    }
    .error {
      color: #e74c3c;
      background: #fdf2f2;
      padding: 10px;
      border-radius: 5px;
      border-left: 4px solid #e74c3c;
    }
    .menubar {
      background: #f0f0f0;
      border-bottom: 1px solid #ccc;
      padding: 0;
      margin: -20px -20px 0 -20px;
      display: flex;
    }
    .menu-item {
      padding: 8px 16px;
      cursor: pointer;
      position: relative;
      user-select: none;
    }
    .menu-item:hover {
      background: #e0e0e0;
    }
    .dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background: white;
      border: 1px solid #ccc;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      min-width: 120px;
      z-index: 2000;
    }
    .dropdown div {
      padding: 8px 16px;
      cursor: pointer;
    }
    .dropdown div:hover {
      background: #f0f0f0;
    }
    .page {
      display: none;
    }
    .page.active {
      display: block;
    }
    input[type="text"] {
      padding: 5px;
      border: 1px solid #ddd;
      border-radius: 3px;
    }
    .chart-tooltip {
      position: absolute;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 8px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
      display: none;
    }
  </style>
</head>
<body>
  <div class="menubar">
    <div class="menu-item" onclick="showHomePage()">üè† Home</div>
    <div class="menu-item" onclick="toggleMenu('systemMenu')">
      ‚öôÔ∏è System
      <div id="systemMenu" class="dropdown">
        <div onclick="showTenantsPage(); closeAllMenus()">üë• Tenants</div>
        <div onclick="showUserTrackingPage(); closeAllMenus()">üìä User Tracking</div>
      </div>
    </div>
    <div class="menu-item" onclick="toggleMenu('manageMenu')">
      üìã Manage
      <div id="manageMenu" class="dropdown">
        <div onclick="showWorkflowsPage(); closeAllMenus()">üîÑ Workflows</div>
      </div>
    </div>
  </div>
  
  <div class="header">
    <h1>Janus Management Studio</h1>
    <p id="headerConnectionInfo">Connected to database</p>
  </div>
  
  <div id="homePage" class="page active">
    <div class="query-section">
      <h3>Welcome to Janus Management Studio</h3>
      <div id="connectionInfo">
        <p><strong>Database:</strong> <span id="currentDatabase">Loading...</span></p>
        <p><strong>Current Tenant:</strong> <span id="currentTenant">None selected</span></p>
      </div>
      <hr>
      <p>Use the menu above to navigate to different sections:</p>
      <ul>
        <li><strong>System ‚Üí Tenants</strong> - View and manage tenant information</li>
        <li><strong>System ‚Üí User Tracking</strong> - View user activity tracking data</li>
        <li><strong>Manage ‚Üí Workflows</strong> - View workflows for selected tenant</li>
      </ul>
    </div>
  </div>

  <div id="tenantsPage" class="page">
    <div class="query-section">
      <h3>System - Tenants</h3>
      <button onclick="loadTenants()">Refresh Tenants</button>
      <button onclick="loadAllTenants()">Show All (Including Deleted)</button>
    </div>
    
    <div class="results">
      <h3>Tenants List</h3>
      <div id="tenantsResults">Loading tenants...</div>
    </div>
  </div>

  <div id="workflowsPage" class="page">
    <div class="query-section">
      <h3>Manage - Workflows</h3>
      <p id="workflowTenantInfo">No tenant selected. Please select a tenant first.</p>
      <button onclick="loadWorkflows()" id="refreshWorkflowsBtn" disabled>Refresh Workflows</button>
    </div>
    
    <div class="results">
      <h3>Workflows List</h3>
      <div id="workflowsResults">Select a tenant to view workflows.</div>
    </div>
  </div>

  <div id="userTrackingPage" class="page">
    <div class="query-section">
      <h3>System - User Tracking</h3>
      <div style="display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">
        <input type="date" id="dateFromFilter" style="width: 150px;" placeholder="From Date">
        <input type="date" id="dateThroughFilter" style="width: 150px;" placeholder="Through Date">
        <select id="moduleFilter" multiple style="width: 150px; height: 80px;">
          <option value="">Loading modules...</option>
        </select>
        <select id="functionFilter" multiple style="width: 150px; height: 80px;">
          <option value="">Loading functions...</option>
        </select>
        <select id="tenantFilter" multiple style="width: 150px; height: 80px;">
          <option value="">Loading tenants...</option>
        </select>
        <button onclick="loadUserTracking(1)">Apply Filters</button>
        <button onclick="clearFilters()">Clear</button>
      </div>
      <div id="trackingPagination" style="margin-bottom: 10px;"></div>
    </div>
    
    <div class="results">
      <h3>User Tracking Data</h3>
      <div id="userTrackingResults">Loading user tracking data...</div>
      
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; width: 100%;">
        <div style="width: 100%; position: relative;">
          <h3>Top 10 Functions</h3>
          <canvas id="functionsChart" width="500" height="300"></canvas>
        </div>
        <div style="width: 100%; position: relative;">
          <h3>Top 10 URL Paths</h3>
          <canvas id="pathsChart" width="500" height="300"></canvas>
        </div>
        <div style="width: 100%; position: relative;">
          <h3>Top 10 Modules</h3>
          <canvas id="modulesChart" width="500" height="300"></canvas>
        </div>
        <div style="width: 100%; position: relative;">
          <h3>Top 10 Users</h3>
          <canvas id="usersChart" width="500" height="300"></canvas>
        </div>
      </div>
      <div id="chartTooltip" class="chart-tooltip"></div>
    </div>
  </div>

  <div id="workflowOpenPage" class="page">
    <div class="query-section">
      <h3 id="workflowTitle">Workflow Details</h3>
      <button onclick="showWorkflowsPage()">‚Üê Back to Workflows</button>
    </div>
    
    <div class="results">
      <h4>Workflow Information</h4>
      <div id="workflowDetails">Loading workflow details...</div>
      
      <h4>Workflow Activities</h4>
      <div id="workflowActivities">Loading activities...</div>
    </div>
  </div>

  <script>
    const { ipcRenderer } = require('electron');
    
    // Load context on page load
    window.addEventListener('DOMContentLoaded', async () => {
      await updateContext();
    });
    
    async function updateContext() {
      try {
        const context = await ipcRenderer.invoke('get-context');
        document.getElementById('currentDatabase').textContent = context.database || 'Not connected';
        document.getElementById('currentTenant').textContent = context.tenant ? 
          `${context.tenant.name} (ID: ${context.tenant.id})` : 'None selected';
        document.getElementById('headerConnectionInfo').textContent = 
          `Connected to ${context.database || 'database'}`;
      } catch (error) {
        console.error('Failed to load context:', error);
      }
    }
    
    function toggleMenu(menuId) {
      const menu = document.getElementById(menuId);
      const isVisible = menu.style.display === 'block';
      
      // Hide all dropdowns
      document.querySelectorAll('.dropdown').forEach(d => d.style.display = 'none');
      
      // Show clicked menu if it wasn't visible
      if (!isVisible) {
        menu.style.display = 'block';
      }
    }
    
    // Close dropdowns when clicking elsewhere
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.menu-item')) {
        closeAllMenus();
      }
    });
    
    function closeAllMenus() {
      document.querySelectorAll('.dropdown').forEach(d => d.style.display = 'none');
    }
    
    function createTable(data) {
      if (!data || data.length === 0) return '';
      
      const headers = Object.keys(data[0]);
      let html = '<table><thead><tr>';
      
      headers.forEach(header => {
        html += `<th>${header}</th>`;
      });
      html += '</tr></thead><tbody>';
      
      data.forEach(row => {
        html += '<tr>';
        headers.forEach(header => {
          const value = row[header] !== null ? row[header] : 'NULL';
          html += `<td>${value}</td>`;
        });
        html += '</tr>';
      });
      
      html += '</tbody></table>';
      return html;
    }
    
    function createTenantsTable(data) {
      if (!data || data.length === 0) return '';
      
      const headers = Object.keys(data[0]);
      let html = '<table><thead><tr><th>Action</th>';
      
      headers.forEach(header => {
        html += `<th>${header}</th>`;
      });
      html += '</tr></thead><tbody>';
      
      data.forEach(row => {
        html += '<tr>';
        html += `<td><button onclick="setTenant(${row.Id}, '${row.Name}')">Set as Current</button></td>`;
        headers.forEach(header => {
          const value = row[header] !== null ? row[header] : 'NULL';
          html += `<td>${value}</td>`;
        });
        html += '</tr>';
      });
      
      html += '</tbody></table>';
      return html;
    }
    
    async function setTenant(tenantId, tenantName) {
      try {
        await ipcRenderer.invoke('set-tenant', tenantId, tenantName);
        alert(`Current tenant set to: ${tenantName} (ID: ${tenantId})`);
        showHomePage();
      } catch (error) {
        alert(`Failed to set tenant: ${error.message}`);
      }
    }
    
    function showHomePage() {
      document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
      document.getElementById('homePage').classList.add('active');
      closeAllMenus();
      updateContext();
    }
    
    function showTenantsPage() {
      document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
      document.getElementById('tenantsPage').classList.add('active');
      document.querySelectorAll('.dropdown').forEach(d => d.style.display = 'none');
      loadTenants();
    }
    
    async function loadTenants() {
      const resultsDiv = document.getElementById('tenantsResults');
      resultsDiv.innerHTML = 'Loading tenants...';
      
      try {
        const result = await ipcRenderer.invoke('execute-query', 
          `SELECT Id, Name, DefaultColor, DefaultPrimaryColor, 
                  CASE WHEN UseLightTheme = 1 THEN 'Yes' ELSE 'No' END as UseLightTheme,
                  CreatedById, CreatedDate, UpdatedById, UpdatedDate,
                  CASE WHEN IsDeleted = 1 THEN 'Yes' ELSE 'No' END as IsDeleted
           FROM Tenants 
           WHERE IsDeleted = 0
           ORDER BY Id`);
        
        if (result.success) {
          if (result.data && result.data.length > 0) {
            const table = createTenantsTable(result.data);
            resultsDiv.innerHTML = `<p>${result.data.length} active tenants found.</p>${table}`;
          } else {
            resultsDiv.innerHTML = '<p>No active tenants found.</p>';
          }
        } else {
          resultsDiv.innerHTML = `<div class="error">Failed to load tenants: ${result.error}</div>`;
        }
      } catch (error) {
        resultsDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
      }
    }
    
    async function loadAllTenants() {
      const resultsDiv = document.getElementById('tenantsResults');
      resultsDiv.innerHTML = 'Loading all tenants...';
      
      try {
        const result = await ipcRenderer.invoke('execute-query', 
          `SELECT Id, Name, DefaultColor, DefaultPrimaryColor, 
                  CASE WHEN UseLightTheme = 1 THEN 'Yes' ELSE 'No' END as UseLightTheme,
                  CreatedById, CreatedDate, UpdatedById, UpdatedDate,
                  CASE WHEN IsDeleted = 1 THEN 'Yes' ELSE 'No' END as IsDeleted,
                  DeletedDate
           FROM Tenants 
           ORDER BY IsDeleted, Id`);
        
        if (result.success) {
          if (result.data && result.data.length > 0) {
            const table = createTable(result.data);
            resultsDiv.innerHTML = `<p>${result.data.length} total tenants found.</p>${table}`;
          } else {
            resultsDiv.innerHTML = '<p>No tenants found.</p>';
          }
        } else {
          resultsDiv.innerHTML = `<div class="error">Failed to load tenants: ${result.error}</div>`;
        }
      } catch (error) {
        resultsDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
      }
    }
    
    function showWorkflowsPage() {
      document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
      document.getElementById('workflowsPage').classList.add('active');
      document.querySelectorAll('.dropdown').forEach(d => d.style.display = 'none');
      updateWorkflowsContext();
    }
    
    async function updateWorkflowsContext() {
      try {
        const context = await ipcRenderer.invoke('get-context');
        const tenantInfo = document.getElementById('workflowTenantInfo');
        const refreshBtn = document.getElementById('refreshWorkflowsBtn');
        
        if (context.tenant) {
          tenantInfo.textContent = `Showing workflows for: ${context.tenant.name} (ID: ${context.tenant.id})`;
          refreshBtn.disabled = false;
          loadWorkflows();
        } else {
          tenantInfo.textContent = 'No tenant selected. Please select a tenant first.';
          refreshBtn.disabled = true;
          document.getElementById('workflowsResults').innerHTML = 'Select a tenant to view workflows.';
        }
      } catch (error) {
        console.error('Failed to load context:', error);
      }
    }
    
    async function loadWorkflows() {
      const resultsDiv = document.getElementById('workflowsResults');
      
      try {
        const context = await ipcRenderer.invoke('get-context');
        if (!context.tenant) {
          resultsDiv.innerHTML = '<div class="error">No tenant selected</div>';
          return;
        }
        
        resultsDiv.innerHTML = 'Loading workflows...';
        
        const result = await ipcRenderer.invoke('execute-query', 
          `SELECT Id, Name, 
                  CASE WHEN SyncEnabled = 1 THEN 'Yes' ELSE 'No' END as SyncEnabled,
                  CASE WHEN IsRouter = 1 THEN 'Yes' ELSE 'No' END as IsRouter,
                  CASE WHEN IsRoutable = 1 THEN 'Yes' ELSE 'No' END as IsRoutable,
                  CASE WHEN IsReRouteAllowed = 1 THEN 'Yes' ELSE 'No' END as IsReRouteAllowed,
                  EmailUserName, EmailMailboxOwner,
                  CreatedById, CreatedDate, UpdatedById, UpdatedDate
           FROM Workflows 
           WHERE TenantId = ${context.tenant.id} AND IsDeleted = 0
           ORDER BY Name`);
        
        if (result.success) {
          if (result.data && result.data.length > 0) {
            const table = createWorkflowsTable(result.data);
            resultsDiv.innerHTML = `<p>${result.data.length} workflows found for tenant ${context.tenant.name}.</p>${table}`;
          } else {
            resultsDiv.innerHTML = `<p>No workflows found for tenant ${context.tenant.name}.</p>`;
          }
        } else {
          resultsDiv.innerHTML = `<div class="error">Failed to load workflows: ${result.error}</div>`;
        }
      } catch (error) {
        resultsDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
      }
    }
    
    function createWorkflowsTable(data) {
      if (!data || data.length === 0) return '';
      
      const headers = Object.keys(data[0]);
      let html = '<table><thead><tr><th>Action</th>';
      
      headers.forEach(header => {
        html += `<th>${header}</th>`;
      });
      html += '</tr></thead><tbody>';
      
      data.forEach(row => {
        html += '<tr>';
        html += `<td><button onclick="openWorkflow(${row.Id}, '${row.Name}')">Open</button></td>`;
        headers.forEach(header => {
          const value = row[header] !== null ? row[header] : 'NULL';
          html += `<td>${value}</td>`;
        });
        html += '</tr>';
      });
      
      html += '</tbody></table>';
      return html;
    }
    
    async function openWorkflow(workflowId, workflowName) {
      document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
      document.getElementById('workflowOpenPage').classList.add('active');
      document.getElementById('workflowTitle').textContent = `Workflow: ${workflowName}`;
      
      await loadWorkflowDetails(workflowId);
      await loadWorkflowActivities(workflowId);
    }
    
    async function loadWorkflowDetails(workflowId) {
      const detailsDiv = document.getElementById('workflowDetails');
      detailsDiv.innerHTML = 'Loading workflow details...';
      
      try {
        const result = await ipcRenderer.invoke('execute-query', 
          `SELECT Id, TenantId, Name, EmailSignature, EmailUserName, EmailMailboxOwner,
                  CASE WHEN SyncEnabled = 1 THEN 'Yes' ELSE 'No' END as SyncEnabled,
                  CASE WHEN IsRouter = 1 THEN 'Yes' ELSE 'No' END as IsRouter,
                  CASE WHEN IsRoutable = 1 THEN 'Yes' ELSE 'No' END as IsRoutable,
                  CASE WHEN IsReRouteAllowed = 1 THEN 'Yes' ELSE 'No' END as IsReRouteAllowed,
                  CreatedById, CreatedDate, UpdatedById, UpdatedDate
           FROM Workflows 
           WHERE Id = ${workflowId}`);
        
        if (result.success && result.data && result.data.length > 0) {
          const table = createTable(result.data);
          detailsDiv.innerHTML = table;
        } else {
          detailsDiv.innerHTML = '<div class="error">Workflow not found</div>';
        }
      } catch (error) {
        detailsDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
      }
    }
    
    async function loadWorkflowActivities(workflowId) {
      const activitiesDiv = document.getElementById('workflowActivities');
      activitiesDiv.innerHTML = 'Loading activities...';
      
      try {
        const result = await ipcRenderer.invoke('execute-query', 
          `SELECT wa.Id, wa.Name, sv.Name as ActivityType, wa.Position,
                  wa.ServiceLevelAgreementTicks,
                  CASE WHEN wa.RequireSubcategoryWhenCategorySelected = 1 THEN 'Yes' ELSE 'No' END as RequireSubcategory,
                  CASE WHEN wa.IsReopenReplyRequired = 1 THEN 'Yes' ELSE 'No' END as ReopenReplyRequired,
                  wa.CreatedById, wa.CreatedDate, wa.UpdatedById, wa.UpdatedDate
           FROM WorkflowActivities wa
           LEFT JOIN SystemValues sv ON wa.ActivityTypeValueId = sv.Id
           WHERE wa.WorkflowId = ${workflowId} AND wa.IsDeleted = 0
           ORDER BY wa.Position`);
        
        if (result.success) {
          if (result.data && result.data.length > 0) {
            const table = createActivitiesTable(result.data, workflowId);
            activitiesDiv.innerHTML = `<p>${result.data.length} activities found.</p>${table}`;
          } else {
            activitiesDiv.innerHTML = '<p>No activities found for this workflow.</p>';
          }
        } else {
          activitiesDiv.innerHTML = `<div class="error">Failed to load activities: ${result.error}</div>`;
        }
      } catch (error) {
        activitiesDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
      }
    }
    
    function createActivitiesTable(activities, workflowId) {
      if (!activities || activities.length === 0) return '';
      
      let html = '';
      
      activities.forEach(activity => {
        html += `<div style="margin-bottom: 20px; border: 1px solid #ddd; padding: 15px; border-radius: 5px;">`;
        html += `<h5>Activity: ${activity.Name} (Position: ${activity.Position})</h5>`;
        html += `<p><strong>Type:</strong> ${activity.ActivityType || 'Unknown'} | <strong>SLA Ticks:</strong> ${activity.ServiceLevelAgreementTicks || 'None'}</p>`;
        html += `<p><strong>Require Subcategory:</strong> ${activity.RequireSubcategory} | <strong>Reopen Reply Required:</strong> ${activity.ReopenReplyRequired}</p>`;
        html += `<div id="roles_${activity.Id}" style="margin-top: 10px;">Loading roles...</div>`;
        html += `<div id="actions_${activity.Id}" style="margin-top: 10px;">Loading actions...</div>`;
        html += `</div>`;
      });
      
      // Load roles and actions for each activity
      setTimeout(() => {
        activities.forEach(activity => {
          loadActivityRoles(activity.Id);
          loadActivityActions(activity.Id);
        });
      }, 100);
      
      return html;
    }
    
    async function loadActivityActions(activityId) {
      const actionsDiv = document.getElementById(`actions_${activityId}`);
      
      try {
        const result = await ipcRenderer.invoke('execute-query', 
          `SELECT waa.Id, waa.Label, sv.Name as ActionType, waa.Position,
                  waa.CreatedById, waa.CreatedDate, waa.UpdatedById, waa.UpdatedDate
           FROM WorkflowActivityAction waa
           LEFT JOIN SystemValues sv ON waa.WorkflowActivityActionValueId = sv.Id
           WHERE waa.WorkflowActivityId = ${activityId} AND waa.IsDeleted = 0
           ORDER BY waa.Position`);
        
        if (result.success) {
          if (result.data && result.data.length > 0) {
            let actionsHtml = '<strong>Actions:</strong><table style="margin-top: 5px; font-size: 11px;"><thead><tr>';
            const headers = Object.keys(result.data[0]);
            headers.forEach(header => {
              actionsHtml += `<th>${header}</th>`;
            });
            actionsHtml += '</tr></thead><tbody>';
            
            result.data.forEach(row => {
              actionsHtml += '<tr>';
              headers.forEach(header => {
                const value = row[header] !== null ? row[header] : 'NULL';
                actionsHtml += `<td>${value}</td>`;
              });
              actionsHtml += '</tr>';
            });
            actionsHtml += '</tbody></table>';
            
            actionsDiv.innerHTML = actionsHtml;
          } else {
            actionsDiv.innerHTML = '<em>No actions defined for this activity.</em>';
          }
        } else {
          actionsDiv.innerHTML = `<em>Error loading actions: ${result.error}</em>`;
        }
      } catch (error) {
        actionsDiv.innerHTML = `<em>Error: ${error.message}</em>`;
      }
    }
    
    async function loadActivityRoles(activityId) {
      const rolesDiv = document.getElementById(`roles_${activityId}`);
      
      try {
        const result = await ipcRenderer.invoke('execute-query', 
          `SELECT war.Id, war.RoleId,
                  war.CreatedById, war.CreatedDate, war.UpdatedById, war.UpdatedDate
           FROM WorkflowActivityRole war
           WHERE war.WorkflowActivityId = ${activityId} AND war.IsDeleted = 0
           ORDER BY war.RoleId`);
        
        if (result.success) {
          if (result.data && result.data.length > 0) {
            let rolesHtml = '<strong>Roles:</strong><table style="margin-top: 5px; font-size: 11px;"><thead><tr>';
            const headers = Object.keys(result.data[0]);
            headers.forEach(header => {
              rolesHtml += `<th>${header}</th>`;
            });
            rolesHtml += '</tr></thead><tbody>';
            
            result.data.forEach(row => {
              rolesHtml += '<tr>';
              headers.forEach(header => {
                const value = row[header] !== null ? row[header] : 'NULL';
                rolesHtml += `<td>${value}</td>`;
              });
              rolesHtml += '</tr>';
            });
            rolesHtml += '</tbody></table>';
            
            rolesDiv.innerHTML = rolesHtml;
          } else {
            rolesDiv.innerHTML = '<em>No roles assigned to this activity.</em>';
          }
        } else {
          rolesDiv.innerHTML = `<em>Error loading roles: ${result.error}</em>`;
        }
      } catch (error) {
        rolesDiv.innerHTML = `<em>Error: ${error.message}</em>`;
      }
    }
    
    function showUserTrackingPage() {
      document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
      document.getElementById('userTrackingPage').classList.add('active');
      document.querySelectorAll('.dropdown').forEach(d => d.style.display = 'none');
      setDefaultDates();
      loadFilterOptions();
      loadUserTracking(1);
    }
    
    function setDefaultDates() {
      const today = new Date().toISOString().split('T')[0];
      document.getElementById('dateFromFilter').value = today;
      document.getElementById('dateThroughFilter').value = today;
    }
    
    async function loadFilterOptions() {
      try {
        // Load modules
        const modules = await ipcRenderer.invoke('execute-query', 'SELECT DISTINCT sm.name FROM SystemModules sm ORDER BY sm.name');
        populateSelect('moduleFilter', modules.data, 'name');
        
        // Load functions
        const functions = await ipcRenderer.invoke('execute-query', 'SELECT DISTINCT sf.Name FROM systemfunctions sf ORDER BY sf.Name');
        populateSelect('functionFilter', functions.data, 'Name');
        
        // Load tenants
        const tenants = await ipcRenderer.invoke('execute-query', 'SELECT DISTINCT t.name FROM Tenants t ORDER BY t.name');
        populateSelect('tenantFilter', tenants.data, 'name');
        

      } catch (error) {
        console.error('Failed to load filter options:', error);
      }
    }
    
    function populateSelect(selectId, data, fieldName) {
      const select = document.getElementById(selectId);
      select.innerHTML = '';
      
      if (data && data.length > 0) {
        data.forEach(item => {
          const option = document.createElement('option');
          option.value = item[fieldName];
          option.textContent = item[fieldName];
          select.appendChild(option);
        });
      }
    }
    
    function getSelectedValues(selectId) {
      const select = document.getElementById(selectId);
      return Array.from(select.selectedOptions).map(option => option.value);
    }
    
    let currentTrackingPage = 1;
    let trackingSortField = 'sut.CreatedDate';
    let trackingSortOrder = 'DESC';
    
    async function loadUserTracking(page = 1) {
      currentTrackingPage = page;
      const resultsDiv = document.getElementById('userTrackingResults');
      const paginationDiv = document.getElementById('trackingPagination');
      
      const moduleFilter = getSelectedValues('moduleFilter');
      const functionFilter = getSelectedValues('functionFilter');
      const tenantFilter = getSelectedValues('tenantFilter');
      const dateFrom = document.getElementById('dateFromFilter').value;
      const dateThrough = document.getElementById('dateThroughFilter').value;
      
      let whereClause = 'WHERE 1=1';
      if (moduleFilter.length > 0) {
        const moduleList = moduleFilter.map(m => `'${m}'`).join(',');
        whereClause += ` AND sm.name IN (${moduleList})`;
      }
      if (functionFilter.length > 0) {
        const functionList = functionFilter.map(f => `'${f}'`).join(',');
        whereClause += ` AND sf.Name IN (${functionList})`;
      }
      if (tenantFilter.length > 0) {
        const tenantList = tenantFilter.map(t => `'${t}'`).join(',');
        whereClause += ` AND t.name IN (${tenantList})`;
      }
      if (dateFrom) {
        whereClause += ` AND sut.CreatedDate >= '${dateFrom}'`;
      }
      if (dateThrough) {
        whereClause += ` AND sut.CreatedDate <= '${dateThrough} 23:59:59'`;
      }
      
      const offset = (page - 1) * 100;
      
      resultsDiv.innerHTML = 'Loading user tracking data...';
      
      try {
        const result = await ipcRenderer.invoke('execute-query', 
          `SELECT TOP 100 * FROM (
             SELECT ROW_NUMBER() OVER (ORDER BY ${trackingSortField} ${trackingSortOrder}) as RowNum,
                    sm.name as [Module], sf.Name as [Function], t.name as [Tenant],
                    a.AccountId as [Account], p.FirstName + ' ' + p.LastName as [User],
                    sut.[Path], sut.CreatedDate
             FROM SystemUserTrackings sut
             INNER JOIN People p ON p.applicationuserid = sut.Createdbyid
             INNER JOIN Accounts a ON a.id = p.AccountId
             INNER JOIN Tenants t ON t.id = a.TenantId
             INNER JOIN systemfunctions sf ON sf.id = sut.FunctionId
             INNER JOIN SystemModules sm ON sm.id = sf.SystemModuleId
             ${whereClause}
           ) AS NumberedResults
           WHERE RowNum > ${offset}
           ORDER BY RowNum`);
        
        if (result.success) {
          if (result.data && result.data.length > 0) {
            const table = createSortableTable(result.data, 'tracking');
            resultsDiv.innerHTML = table;
            
            // Update pagination
            const hasMore = result.data.length === 100;
            updatePagination(page, hasMore, 'loadUserTracking');
            
            // Load chart data
            loadAllCharts();
          } else {
            resultsDiv.innerHTML = '<p>No user tracking data found.</p>';
            paginationDiv.innerHTML = '';
          }
        } else {
          resultsDiv.innerHTML = `<div class="error">Failed to load user tracking: ${result.error}</div>`;
        }
      } catch (error) {
        resultsDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
      }
    }
    
    function createSortableTable(data, tableType) {
      if (!data || data.length === 0) return '';
      
      const headers = Object.keys(data[0]);
      let html = '<table><thead><tr>';
      
      headers.forEach(header => {
        html += `<th style="cursor: pointer;" onclick="sortTable('${header}', '${tableType}')">${header} ‚Üï</th>`;
      });
      html += '</tr></thead><tbody>';
      
      data.forEach(row => {
        html += '<tr>';
        headers.forEach(header => {
          const value = row[header] !== null ? row[header] : 'NULL';
          html += `<td>${value}</td>`;
        });
        html += '</tr>';
      });
      
      html += '</tbody></table>';
      return html;
    }
    
    function sortTable(field, tableType) {
      if (tableType === 'tracking') {
        trackingSortOrder = (trackingSortField === field && trackingSortOrder === 'ASC') ? 'DESC' : 'ASC';
        trackingSortField = field;
        loadUserTracking(currentTrackingPage);
      }
    }
    
    function updatePagination(currentPage, hasMore, loadFunction) {
      const paginationDiv = document.getElementById('trackingPagination');
      let html = `Page ${currentPage} `;
      
      if (currentPage > 1) {
        html += `<button onclick="${loadFunction}(${currentPage - 1})">Previous</button> `;
      }
      
      if (hasMore) {
        html += `<button onclick="${loadFunction}(${currentPage + 1})">Next</button>`;
      }
      
      paginationDiv.innerHTML = html;
    }
    
    function clearFilters() {
      document.getElementById('moduleFilter').selectedIndex = -1;
      document.getElementById('functionFilter').selectedIndex = -1;
      document.getElementById('tenantFilter').selectedIndex = -1;
      setDefaultDates();
      loadUserTracking(1);
    }
    
    function getWhereClause() {
      const moduleFilter = getSelectedValues('moduleFilter');
      const functionFilter = getSelectedValues('functionFilter');
      const tenantFilter = getSelectedValues('tenantFilter');
      const dateFrom = document.getElementById('dateFromFilter').value;
      const dateThrough = document.getElementById('dateThroughFilter').value;
      
      let whereClause = 'WHERE 1=1';
      if (moduleFilter.length > 0) {
        const moduleList = moduleFilter.map(m => `'${m}'`).join(',');
        whereClause += ` AND sm.name IN (${moduleList})`;
      }
      if (functionFilter.length > 0) {
        const functionList = functionFilter.map(f => `'${f}'`).join(',');
        whereClause += ` AND sf.Name IN (${functionList})`;
      }
      if (tenantFilter.length > 0) {
        const tenantList = tenantFilter.map(t => `'${t}'`).join(',');
        whereClause += ` AND t.name IN (${tenantList})`;
      }
      if (dateFrom) {
        whereClause += ` AND sut.CreatedDate >= '${dateFrom}'`;
      }
      if (dateThrough) {
        whereClause += ` AND sut.CreatedDate <= '${dateThrough} 23:59:59'`;
      }
      return whereClause;
    }
    
    async function loadAllCharts() {
      const whereClause = getWhereClause();
      
      try {
        // Functions chart
        const functionsResult = await ipcRenderer.invoke('execute-query', 
          `SELECT TOP 10 sf.Name as [Function], COUNT(*) as [Count]
           FROM SystemUserTrackings sut
           INNER JOIN People p ON p.applicationuserid = sut.Createdbyid
           INNER JOIN Accounts a ON a.id = p.AccountId
           INNER JOIN Tenants t ON t.id = a.TenantId
           INNER JOIN systemfunctions sf ON sf.id = sut.FunctionId
           INNER JOIN SystemModules sm ON sm.id = sf.SystemModuleId
           ${whereClause}
           GROUP BY sf.Name
           ORDER BY COUNT(*) DESC`);
        
        if (functionsResult.success && functionsResult.data) {
          drawPieChart(functionsResult.data, 'functionsChart');
          addChartTooltips('functionsChart', functionsResult.data, 'pie', 'Function');
        }
        
        // Paths chart
        const pathsResult = await ipcRenderer.invoke('execute-query', 
          `SELECT TOP 10 sut.[Path], COUNT(*) as [Count]
           FROM SystemUserTrackings sut
           INNER JOIN People p ON p.applicationuserid = sut.Createdbyid
           INNER JOIN Accounts a ON a.id = p.AccountId
           INNER JOIN Tenants t ON t.id = a.TenantId
           INNER JOIN systemfunctions sf ON sf.id = sut.FunctionId
           INNER JOIN SystemModules sm ON sm.id = sf.SystemModuleId
           ${whereClause}
           GROUP BY sut.[Path]
           ORDER BY COUNT(*) DESC`);
        
        if (pathsResult.success && pathsResult.data) {
          drawBarChart(pathsResult.data, 'pathsChart', 'Path');
          addChartTooltips('pathsChart', pathsResult.data, 'bar', 'Path');
        }
        
        // Modules chart
        const modulesResult = await ipcRenderer.invoke('execute-query', 
          `SELECT TOP 10 sm.name as [Module], COUNT(*) as [Count]
           FROM SystemUserTrackings sut
           INNER JOIN People p ON p.applicationuserid = sut.Createdbyid
           INNER JOIN Accounts a ON a.id = p.AccountId
           INNER JOIN Tenants t ON t.id = a.TenantId
           INNER JOIN systemfunctions sf ON sf.id = sut.FunctionId
           INNER JOIN SystemModules sm ON sm.id = sf.SystemModuleId
           ${whereClause}
           GROUP BY sm.name
           ORDER BY COUNT(*) DESC`);
        
        if (modulesResult.success && modulesResult.data) {
          drawBarChart(modulesResult.data, 'modulesChart', 'Module');
          addChartTooltips('modulesChart', modulesResult.data, 'bar', 'Module');
        }
        
        // Users chart
        const usersResult = await ipcRenderer.invoke('execute-query', 
          `SELECT TOP 10 p.FirstName + ' ' + p.LastName as [User], COUNT(*) as [Count]
           FROM SystemUserTrackings sut
           INNER JOIN People p ON p.applicationuserid = sut.Createdbyid
           INNER JOIN Accounts a ON a.id = p.AccountId
           INNER JOIN Tenants t ON t.id = a.TenantId
           INNER JOIN systemfunctions sf ON sf.id = sut.FunctionId
           INNER JOIN SystemModules sm ON sm.id = sf.SystemModuleId
           ${whereClause}
           GROUP BY p.FirstName, p.LastName
           ORDER BY COUNT(*) DESC`);
        
        if (usersResult.success && usersResult.data) {
          drawBarChart(usersResult.data, 'usersChart', 'User');
          addChartTooltips('usersChart', usersResult.data, 'bar', 'User');
        }
        
      } catch (error) {
        console.error('Failed to load chart data:', error);
      }
    }
    
    function drawPieChart(data, canvasId) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      if (!data || data.length === 0) return;
      
      const total = data.reduce((sum, item) => sum + item.Count, 0);
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(centerX, centerY) - 20;
      
      let currentAngle = 0;
      const colors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'];
      
      data.forEach((item, index) => {
        const sliceAngle = (item.Count / total) * 2 * Math.PI;
        
        // Draw slice
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
        ctx.closePath();
        ctx.fillStyle = colors[index % colors.length];
        ctx.fill();
        
        // Draw label
        const labelAngle = currentAngle + sliceAngle / 2;
        const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
        const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
        
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        const label = item.Function || item.Module || item.User || item.Path;
        ctx.fillText(label.length > 10 ? label.substring(0, 10) + '...' : label, labelX, labelY);
        ctx.fillText(item.Count, labelX, labelY + 12);
        
        currentAngle += sliceAngle;
      });
    }
    
    function drawBarChart(data, canvasId, labelField) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      if (!data || data.length === 0) return;
      
      const maxCount = Math.max(...data.map(item => item.Count));
      const barWidth = (canvas.width - 120) / data.length;
      const maxBarHeight = canvas.height - 150;
      
      const colors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'];
      
      data.forEach((item, index) => {
        const barHeight = (item.Count / maxCount) * maxBarHeight;
        const x = 60 + index * barWidth;
        const y = canvas.height - 130 - barHeight;
        
        // Draw bar
        ctx.fillStyle = colors[index % colors.length];
        ctx.fillRect(x, y, barWidth - 10, barHeight);
        
        // Draw count on top of bar
        ctx.fillStyle = 'black';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(item.Count, x + barWidth/2, y - 5);
        
        // Draw label at bottom
        ctx.save();
        ctx.translate(x + barWidth/2, canvas.height - 50);
        ctx.rotate(-Math.PI/4);
        ctx.textAlign = 'right';
        ctx.font = '10px Arial';
        const label = item[labelField] || '';
        ctx.fillText(label.length > 15 ? label.substring(0, 15) + '...' : label, 0, 0);
        ctx.restore();
      });
    }
    
    function addChartTooltips(canvasId, data, chartType, labelField) {
      const canvas = document.getElementById(canvasId);
      const tooltip = document.getElementById('chartTooltip');
      
      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        let hoveredItem = null;
        
        if (chartType === 'pie') {
          hoveredItem = getPieSliceAt(x, y, data, canvas);
        } else if (chartType === 'bar') {
          hoveredItem = getBarAt(x, y, data, canvas);
        }
        
        if (hoveredItem) {
          const label = hoveredItem[labelField] || hoveredItem.Function || hoveredItem.Module || hoveredItem.User || hoveredItem.Path;
          tooltip.innerHTML = `${label}<br>Count: ${hoveredItem.Count}`;
          tooltip.style.display = 'block';
          tooltip.style.left = (e.clientX + 10) + 'px';
          tooltip.style.top = (e.clientY - 10) + 'px';
        } else {
          tooltip.style.display = 'none';
        }
      });
      
      canvas.addEventListener('mouseleave', () => {
        tooltip.style.display = 'none';
      });
    }
    
    function getPieSliceAt(x, y, data, canvas) {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(centerX, centerY) - 20;
      
      const dx = x - centerX;
      const dy = y - centerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > radius) return null;
      
      let angle = Math.atan2(dy, dx);
      if (angle < 0) angle += 2 * Math.PI;
      
      const total = data.reduce((sum, item) => sum + item.Count, 0);
      let currentAngle = 0;
      
      for (let i = 0; i < data.length; i++) {
        const sliceAngle = (data[i].Count / total) * 2 * Math.PI;
        if (angle >= currentAngle && angle <= currentAngle + sliceAngle) {
          return data[i];
        }
        currentAngle += sliceAngle;
      }
      
      return null;
    }
    
    function getBarAt(x, y, data, canvas) {
      const barWidth = (canvas.width - 120) / data.length;
      const maxBarHeight = canvas.height - 150;
      const maxCount = Math.max(...data.map(item => item.Count));
      
      for (let i = 0; i < data.length; i++) {
        const barHeight = (data[i].Count / maxCount) * maxBarHeight;
        const barX = 60 + i * barWidth;
        const barY = canvas.height - 130 - barHeight;
        
        if (x >= barX && x <= barX + barWidth - 10 && y >= barY && y <= barY + barHeight) {
          return data[i];
        }
      }
      
      return null;
    }
  </script>
</body>
</html>